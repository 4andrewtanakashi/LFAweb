package com.ufla.lfapp.utils;

import com.ufla.lfapp.R;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by carlos on 10/21/17.
 */

public class ResourcesTest {

    private static Map<Integer, String> resources = new HashMap<>();

    static {
        init();
    }

    private static void init() {

        resources.put(R.string.app_name, "LFApp");
        resources.put(R.string.hello_world, "Hello World");
        resources.put(R.string.action_settings, "Settings");
        resources.put(R.string.type, "Type");
        resources.put(R.string.rule_left_side, "u");
        resources.put(R.string.rule_right_side, "v");
        resources.put(R.string.regular_grammar, "Regular grammar");
        resources.put(R.string.rg_u, "u ∈ V");
        resources.put(R.string.rg_v, "v ∈ λ | Σ | ΣV");
        resources.put(R.string.context_free_grammar, "Context-Free Grammar");
        resources.put(R.string.cfg_u, "u ∈ V");
        resources.put(R.string.cfg_v, "v ∈ (V ∪ Σ)∗");
        resources.put(R.string.context_sensitive_grammar, "Context-Sensitive Grammar");
        resources.put(R.string.csg_u, "u ∈ (V ∪ Σ)+");
        resources.put(R.string.csg_v, "v ∈ (V ∪ Σ)+");
        resources.put(R.string.csg_condition, "|u| ≤ |v|");
        resources.put(R.string.unrestricted_grammar, "Unrestricted Grammar");
        resources.put(R.string.ug_u, "u ∈ (V ∪ Σ)+");
        resources.put(R.string.ug_v, "v ∈ (V ∪ Σ)*");
        resources.put(R.string.logo_ufla, "Logo UFLA");
        resources.put(R.string.team, "Carlos Pereira\ncarloshpereira27 (at) gmail.com\n\nJuventino Neto\njneto (at) computacao.ufla.br\n\nRicardo Terra\nterra (at) dcc.ufla.br");
        resources.put(R.string.team_html, "<font size=\"18\"><b>Carlos Pereira</b></font><br /><font size=\"15\">carloshpereira27 (at) gmail.com</font><br /><br /><b><font size=\"18\">Juventino Neto</font></b><br /><font size=\"15\">jneto (at) computacao.ufla.br</font><br /><br /><b><font size=\"18\">Ricardo Terra</font></b><br /><font size=\"15\">terra (at) dcc.ufla.br</font>");
        resources.put(R.string.lfapp_icon, "LFApp Icon");
        resources.put(R.string.close, "Close");
        resources.put(R.string.grammar_td, "Grammar:");
        resources.put(R.string.word_description_grammar, "Word (if you want to verify acceptances and derivations):");
        resources.put(R.string.lambda, "λ");
        resources.put(R.string.arrow, "→");
        resources.put(R.string.pipe, "|");
        resources.put(R.string.ok, "OK");
        resources.put(R.string.about_button, "About");
        resources.put(R.string.removing_left_recursive_algol_p1, "(2) Remove recursions in order:<br/><b>PSEUDOCODE</b><br/><b>for</b> i = 1 to n <b>do</b><br/>&nbsp;&nbsp;&nbsp;<b>if</b> A<sub><small>i</sub></small> has direct left recursion <b>then</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eliminate recursion in A<sub><small>i</sub></small><br/>&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;<b>for</b> j = i+1 to n <b>do</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> each production in A<sub><small>j</sub></small> <b>do</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> A<sub><small>j</sub></small> → A<sub><small>i</sub></small>γ <b>then</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace A<sub><small>j</sub></small> → A<sub><small>i</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with A<sub><small>j</sub></small> → δ<sub><small>1</sub></small>γ | δ<sub><small>2</sub></small>γ | … | δ<sub><small>k</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where A<sub><small>i</sub></small> → δ<sub><small>1</sub></small> | δ<sub><small>2</sub></small> | … | δ<sub><small>k</sub></small><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are all current productions of A<sub><small>i</sub></small><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;<b>end</b><br/><b>end</b><br/>");
        resources.put(R.string.removing_left_recursive_algol_p2, "(1) Remove rules of type A<sub><small>j</sub></small> → A<sub><small>i</sub></small>γ, in the reverse order of that used to remove left recursion:<br/><b>PSEUDOCODE</b><br/>&<b>for</b> i = n to 1 <b>do</b><br/>&nbsp;&nbsp;&nbsp;<b>for</b> j = i-1 to 1 <b>do</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for</b> each production in A<sub><small>j</sub></small> <b>do</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> A<sub><small>j</sub></small> → A<sub><small>i</sub></small>γ <b>then</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace A<sub><small>j</sub></small> → A<sub><small>i</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with A<sub><small>j</sub></small> → δ<sub><small>1</sub></small>γ | δ<sub><small>2</sub></small>γ | … | δ<sub><small>k</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where A<sub><small>i</sub></small> → δ<sub><small>1</sub></small> | δ<sub><small>2</sub></small> | … | δ<sub><small>k</sub></small><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;are all current productions of A<sub><small>i</sub></small><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;<b>end</b><br/><b>end</b><br/>");
        resources.put(R.string.removing_left_recursive_algol_p3, "(2) Remove rules of type R<sub><small>i</sub></small> → Vγ in the variables created by the left recursion removal algorithm, in order:<br/><b>PSEUDOCODE</b><br/><b>for</b> i = 1 to n <b>do</b><br/>&nbsp;&nbsp;&nbsp;<b>for</b> each production in Z<sub><small>i</sub></small> <b>do</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> Z<sub><small>i</sub></small> → Vγ <b>then</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace Z<sub><small>i</sub></small> → Vγ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with Z<sub><small>i</sub></small> → δ<sub><small>1</sub></small>γ | δ<sub><small>2</sub></small>γ | … | δ<sub><small>k</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where V → δ<sub><small>1</sub></small> | δ<sub><small>2</sub></small> | … | δ<sub><small>k</sub></small><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;<b>end</b><br/><b>end</b><br/>");
        resources.put(R.string.removing_left_recursive_terra_algol_p1, "(2) Remove recursions in order:<br/><b>PSEUDOCODE</b><br/>A = Sorted set of variables (1º the start symbol and then in order of definition)<br/><b>for</b> i = 1 to n <b>do</b><br/>&nbsp;&nbsp;&nbsp;<b>for</b> each production in A<sub><small>i</sub></small> <b>do</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> A<sub><small>i</sub></small> → A<sub><small>j</sub></small>γ <b>and</b> j < i <b>then</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace A<sub><small>i</sub></small> → A<sub><small>j</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with A<sub><small>i</sub></small> → δ<sub><small>1</sub></small>γ | δ<sub><small>2</sub></small>γ | … | δ<sub><small>k</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where A<sub><small>j</sub></small> → δ<sub><small>1</sub></small> | δ<sub><small>2</sub></small> | … | δ<sub><small>k</sub></small> are all current productions of A<sub><small>j</sub></small><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;<b>end</b><br/><b>if</b> A<sub><small>i</sub></small> has direct left recursion <b>then</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eliminate recursion in A<sub><small>i</sub></small><br/>&nbsp;&nbsp;&nbsp;<b>end</b><br/><b>end</b><br/>");
        resources.put(R.string.removing_left_recursive_terra_algol_p2, "(3) Remove rules of type A<sub><small>i</sub></small> → A<sub><small>j</sub></small>γ, in the reverse order of that used to remove left recursion:<br/><b>PSEUDOCODE</b><br/>A = Sorted set of variables (1º the start symbol and then in order of definition)<br/><b>for</b> i = n-1 to 1 <b>do</b><br/>&nbsp;&nbsp;&nbsp;<b>for</b> each production in A<sub><small>i</sub></small> <b>do</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> A<sub><small>i</sub></small> → A<sub><small>j</sub></small>γ <b>then</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace A<sub><small>i</sub></small> → A<sub><small>j</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with A<sub><small>i</sub></small> → δ<sub><small>1</sub></small>γ | δ<sub><small>2</sub></small>γ | … | δ<sub><small>k</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where A<sub><small>j</sub></small> → δ<sub><small>1</sub></small> | δ<sub><small>2</sub></small> | … | δ<sub><small>k</sub></small> are all current productions of A<sub><small>j</sub></small><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;<b>end</b><br/><b>end</b><br/>");
        resources.put(R.string.removing_left_recursive_terra_algol_p3, "(4) Remove rules of type R<sub><small>i</sub></small> → A<sub><small>j</sub></small>γ in the variables created by the left recursion removal algorithm, in order:<br/><b>PSEUDOCODE</b><br/>A = Sorted set of variables (1º the start symbol and then in order of definition)<br/>R = Set of variables created by the remove left recursion algorithm sorted by order of creation<br/>n = size of set R<br/><b>for</b> i = 1 to n <b>do</b><br/>&nbsp;&nbsp;&nbsp;<b>for</b> each production in R<sub><small>i</sub></small> <b>do</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> R<sub><small>i</sub></small> → A<sub><small>j</sub></small>γ <b>then</b><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace R<sub><small>i</sub></small> → A<sub><small>j</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with R<sub><small>i</sub></small> → δ<sub><small>1</sub></small>γ | δ<sub><small>2</sub></small>γ | … | δ<sub><small>k</sub></small>γ<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;where A<sub><small>j</sub></small> → δ<sub><small>1</sub></small> | δ<sub><small>2</sub></small> | … | δ<sub><small>k</sub></small> are all current productions of A<sub><small>j</sub></small><br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b><br/>&nbsp;&nbsp;&nbsp;<b>end</b><br/><b>end</b><br/>");
        resources.put(R.string.lfapp, "LFApp:");
        resources.put(R.string.lfapp_description, "LFApp is a mobile application to assist the teaching and learning of Formal Languages and Automata (FLA).");
        resources.put(R.string.user_help_grammar, "The user should enter a grammar with the following settings: - Must start with a capital letter - The first symbol will be the start symbol - Capital letters are considered variables - Lowercase letters are considered terminals.");
        resources.put(R.string.develop_juv, "Desenvolvido por Juventino Neto sob orientação de Ricardo Terra.");
        resources.put(R.string.title_activity_fullscreen, "FullscreenActivity");
        resources.put(R.string.dummy_button, "Dummy Button");
        resources.put(R.string.dummy_content, "DUMMY\nCONTENT");
        resources.put(R.string.input_grammar, "Input grammar:");
        resources.put(R.string.grammar_identification, "Grammar Identification");
        resources.put(R.string.leftmost_derivation, "Leftmost Derivation");
        resources.put(R.string.elimination_recursion_start_symbol, "Elimination of the Recursion of the Start Symbol");
        resources.put(R.string.elimination_empty_productions, "Elimination of Lambda Rules");
        resources.put(R.string.elimination_chain_rules, "Elimination of Chain Rules");
        resources.put(R.string.term, "Remove Variables That Do Not Generate Terminal Strings");
        resources.put(R.string.reach, "Remove Unreachable Symbols");
        resources.put(R.string.chomsky_normal_form, "Chomsky Normal Form");
        resources.put(R.string.removal_direct_left_recursion, "Removal of Direct Left Recursion");
        resources.put(R.string.removal_left_recursion, "Removal of Direct and Indirect Left Recursion");
        resources.put(R.string.greibach_normal_form, "Greibach Normal Form");
        resources.put(R.string.cyk, "CYK");
        resources.put(R.string.explanation_grammar_type, "The classification of a grammar is made by the type of its rules (u → v). The table below shows the format of rules characteristic of each level: \n");
        resources.put(R.string.pending, "Pending.");
        resources.put(R.string.result, "Result:");
        resources.put(R.string.algorithm, "Algorithm:");
        resources.put(R.string.properties_chomsky_normal_form, "Chomsky Normal Form");
        resources.put(R.string.properties_greibach_normal_form, "Greibach Normal Form");
        resources.put(R.string.back, "Back");
        resources.put(R.string.next, "Next");
        resources.put(R.string.copy, "Copy");
        resources.put(R.string.delete_grammar, "Delete grammar.");
        resources.put(R.string.clean_history, "Clean history");
        resources.put(R.string.state_machine, "State Machine");
        resources.put(R.string.history, "History");
        resources.put(R.string.title_activity_regex_to_automata, "RegexToAutomataActivity");
        resources.put(R.string.title_activity_automaton_minimization, "AutomatonMinimizationActivity");
        resources.put(R.string.algol_automaton_minimization, "<b>Input:</b> AFD M = <i>(Q, Σ, δ, q<sub><small>0</small></sub>, F)</i><br><b>1</b> For all pairs of states <i>q<sub><small>i</small></sub></i> and <i>q<sub><small>j</small></sub></i> , <i>i</i> < <i>j</i>, do:<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>1.1</b> <i>D</i>[<i>i</i>, <i>j</i>] = 0<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>1.2</b> <i>S</i>[<i>i</i>, <i>j</i>] = ∅<br><b>2</b> For each pair [<i>i</i>, <i>j</i>], <i>i</i> < <i>j</i>, if one is final state and the other isn\'t, do <i>D</i>[<i>i</i>, <i>j</i>] = 1<br><b>3</b> For each pair [<i>i</i>, <i>j</i>], <i>i</i> < <i>j</i> and <i>D</i>[<i>i</i>, <i>j</i>] = 0, do:<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>3.1</b> if there is a ∈ Σ such that δ(<i>q<sub><small>i</small></sub></i>, <i>a</i>) = <i>q<sub><small>n</small></sub></i> and δ(<i>q<sub><small>j</small></sub></i> , <i>a</i>) = <i>q<sub><small>n</small></sub></i> and (<i>D</i>[<i>m</i>, n] = 1 or <i>D</i>[n, <i>m</i>] = 1) then:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>•</b> DIST (<i>i</i>, <i>j</i>) //change <i>D</i>[<i>i</i>, <i>j</i>] = 1 and propagate the distinction to the elements of <i>S</i>[<i>i</i>, <i>j</i>]<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>3.2</b> for each <i>a</i> ∈ Σ such that (q<sub><small>i</small></sub> , <i>a</i>) = q<sub><small>m</small></sub> and (q<sub><small>j</small></sub> , <i>a</i>) = q<sub><small>n</small></sub><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>•</b> if <i>m</i> < n and [<i>i</i>, <i>j</i>] ≠ [<i>m</i>, n], then add [<i>i</i>, <i>j</i>] to <i>S</i>[<i>m</i>, n]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>•</b> if <i>m</i> > n and [<i>i</i>, <i>j</i>] ≠ [n, <i>m</i>], then add [<i>i</i>, <i>j</i>] to <i>S</i>[n, <i>m</i>]<br><b>4</b> For each <i>D</i>[<i>i</i>, <i>j</i>] = 0, the <states></states> <i>i</i> and <i>j</i> can be merged");
        resources.put(R.string.ambiguity_check, "Ambiguity check");
        resources.put(R.string.title_activity_cfgto_pdastage1, "CFGToPDAStage1Activity");
        resources.put(R.string.title_activity_cfgto_pdastage2, "CFGToPDAStage2Activity");
        resources.put(R.string.title_activity_cfgto_pdastage3, "CFGToPDAStage3Activity");
        resources.put(R.string.cfgToPDAStage1Descr, "Greibach Normal Form:<br>A → aA<sub><small>1</small></sub>A<sub><small>2</small></sub>A<sub><small>3</small></sub> … A<sub><small>n</small></sub> where a ∈ Σ and A<sub><small>1..n</small></sub> ∈ V - {S}<br>A → a<br>S → λ");
        resources.put(R.string.cfgToPDAStage2Descr, "Create an PDA extended M = (Q, Σ, Γ, δ, q0, F): <sub><small>(start state q0)</small></sub><br>Q<sub><small>M</small></sub> = {q0, q1}, Σ<sub><small>M</small></sub> = Σ<sub><small>G</small></sub>, Γ<sub><small>M</small></sub> = V<sub><small>G</small></sub> - {S}, F<sub><small>M</small></sub>={q1}");
        resources.put(R.string.cfgToPDAStage3Descr, "If S → λ ∈ P then δ(q<sub><small>0</small></sub>,λ,λ)=[q<sub><small>1</small></sub>,λ]<br>If S → aw ∈ P then δ(q<sub><small>0</small></sub>,a,λ)=[q<sub><small>1</small></sub>,w]");
        resources.put(R.string.cfgToPDAStage4Descr, "If A → aw ∈ P e A ∈ V - {S} then δ(q<sub><small>0</small></sub>,a,A)=[q<sub><small>1</small></sub>,w]");
        resources.put(R.string.algolPDAToCFGStage4, "For all q<sub><small>k</small></sub> ∈ Q<br><b>•&nbsp;</b><q<sub><small>k</small></sub>, λ, q<sub><small>k</small></sub>> &rarr; λ");
        resources.put(R.string.algolPDAToCFGStage1, "<b>•&nbsp;</b>All language accepted by an PDA is an CFL<br><b>•&nbsp;</b>Given an AP, generate an PDA extend M\' where <i>δ\'</i> inherits all transitions from <i>δ</i> and adds two <under>new<under> transitions:<br>&nbsp;&nbsp;&nbsp;<b>•&nbsp;</b>If q<sub><small>j</small></sub>, λ] ∈ <i>δ</i> (q<sub><small>i</small></sub>, u, λ) then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>•&nbsp;</b>[q<sub><small>j</small></sub>, A] ∈ <i>δ\'</i> (q<sub><small>i</small></sub>, u, A), for all A ∈ Γ<br>&nbsp;&nbsp;&nbsp;<b>•&nbsp;</b>If [q<sub><small>j</small></sub>, B] ∈ <i>δ</i>(q<sub><small>i</small></sub>, u, λ) then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>•&nbsp;</b>[q<sub><small>j</small></sub>, BA] ∈ <i>δ\'</i> (q<sub><small>i</small></sub>, u, A), for all A ∈ Γ<br><b>•&nbsp;</b>Interpretation for new transitions:<br>&nbsp;&nbsp;&nbsp;<b>•&nbsp;</b>All transitions that do not pop, are now push and pop the same symbol<br>&nbsp;&nbsp;&nbsp;<b>•&nbsp;</b>See that is for all A ∈ Γ<sub><small>M</small></sub> (whatever it is the top)<br><b>•&nbsp;</b>Clearly, L(M) = L(M\')<br><b>•&nbsp;</b>Variables will not be uppercase, but tuples of the form <q<sub><small>i</small></sub>, A, q<sub><small>j</small></sub>><br><b>•&nbsp;</b>I\'m in <b>q<sub><small>i</small></sub></b>,<br><b>•&nbsp;</b>I want to go to <b>q<sub><small>j</small></sub></b> and<br><b>•&nbsp;</b>exist <b>A</b> at the top of the stack<br>");
        resources.put(R.string.algolPDAToCFG, "<b>•&nbsp;</b>Rules of G:&nbsp;&nbsp;&nbsp;<b><font color=\"blue\">#1</font></b> S &rarr; <q<sub><small>0</small></sub>, λ, q<sub><small>j</small></sub>>, for all q<sub><small>j</small></sub> ∈ F&nbsp;&nbsp;&nbsp;");
        resources.put(R.string.algolPDAToCFGStage2, "<b>#1&nbsp;</b>S → <q<sub><small>0</small></sub>, λ, q<sub><small>j</small></sub>>, for all q<sub><small>j</small></sub> ∈ F");
        resources.put(R.string.algolPDATOCFGRule2, "<b>#2</b> If [q<sub><small>j</small></sub>, B] ∈ <i>δ\'</i>(q<sub><small>i</small></sub>, x, A), then\t(A and B ∈ Γ U {λ})\n\t<b>•</b> <q<sub><small>i</small></sub>, A, <cb:#786DBE>q<sub><small>k</small></sub></cb>> → x<q<sub><small>j</small></sub>, B, <cb:#786DBE>q<sub><small>k</small></sub></cb>>, for all <cb:#786DBE>q<sub><small>k</small></sub></cb> ∈ Q\n");
        resources.put(R.string.algolPDATOCFGRule3, "<b>#3</b> If [q<sub><small>j</small></sub>, BA] ∈ <i>δ\'</i>(q<sub><small>i</small></sub>, x, A), then\t(A e B ∈ Γ)\n\t<b>•</b> <q<sub><small>i</small></sub>, A, <cb:#786DBE>q<sub><small>k</small></sub></cb>> → x<q<sub><small>j</small></sub>, B, q<sub><small>n</small></sub>><<cb:#8FD45A>q<sub><small>n</small></sub></cb>, A, <cb:#786DBE>q<sub><small>k</small></sub></cb>>, <cb:#786DBE>q<sub><small>k</small></sub></cb>, <cb:#8FD45A>q<sub><small>n</small></sub></cb> ∈ Q\n");
        resources.put(R.string.algolPDAToCFGStage3, "<b>#2</b> If [q<sub><small>j</small></sub>, B] ∈ <i>δ\'</i>(q<sub><small>i</small></sub>, x, A), then\t(A e B ∈ Γ U {λ})\n\t<b>•</b> <q<sub><small>i</small></sub>, A, <cb:#786DBE>q<sub><small>k</small></sub></cb>> → x<q<sub><small>j</small></sub>, B, <cb:#786DBE>q<sub><small>k</small></sub></cb>>, para todo <cb:#786DBE>q<sub><small>k</small></sub></cb> ∈ Q\n<b>#3</b> If [q<sub><small>j</small></sub>, BA] ∈ <i>δ\'</i>(q<sub><small>i</small></sub>, x, A), then\t(A e B ∈ Γ)\n\t<b>•</b> <q<sub><small>i</small></sub>, A, <cb:#786DBE>q<sub><small>k</small></sub></cb>> → x<q<sub><small>j</small></sub>, B, q<sub><small>n</small></sub>><<cb:#8FD45A>q<sub><small>n</small></sub></cb>, A, <cb:#786DBE>q<sub><small>k</small></sub></cb>>, <cb:#786DBE>q<sub><small>k</small></sub></cb>, <cb:#8FD45A>q<sub><small>n</small></sub></cb> ∈ Q\n");
        resources.put(R.string.input, "Input:");
        resources.put(R.string.output, "Output:");
        resources.put(R.string.end, "End");
        resources.put(R.string.previous, "Previous");
        resources.put(R.string.algorithm_abr, "Algol");
        resources.put(R.string.cancel, "Cancel");
        resources.put(R.string.convert_gnf_title, "Convert grammar into Greibach Normal Form");
        resources.put(R.string.create_pda_extended, "Create an PDA Extended");
        resources.put(R.string.transitions_using_initial_symbol, "Transitions using start symbol");
        resources.put(R.string.transitions_using_not_initial_symbol, "Transitions using non start symbol");
        resources.put(R.string.finite_state_automaton, "Finite-state automaton");
        resources.put(R.string.pushdown_automaton, "Pushdown Automaton");
        resources.put(R.string.turing_machine, "Turing Machine / Linear Bounded Automaton");
        resources.put(R.string.multi_track_tm, "Multi-track TM");
        resources.put(R.string.multi_tape_tm, "Multi-tape TM");
        resources.put(R.string.enumerator_tm, "Enumerator TM");
        resources.put(R.string.grammar, "Grammar");
        resources.put(R.string.convert_cfg_into_pda, "Convert CFG into pushdown automaton");
        resources.put(R.string.input_pda, "Input pushdown automaton:");
        resources.put(R.string.generate_pda_extend, "Generate pushdown automaton extend");
        resources.put(R.string.new_transitions, "New transitions:");
        resources.put(R.string.pda_extend, "Pushdown automaton extend:");
        resources.put(R.string.generate_rules_initial_symbol, "Generate rules with the start symbol");
        resources.put(R.string.new_rules, "New rules:");
        resources.put(R.string.generate_rules_automaton_transitions, "Generate rules with automaton transitions");
        resources.put(R.string.current_grammar, "Current grammar:");
        resources.put(R.string.generate_lambda_rules, "Generate lambda rules");
        resources.put(R.string.rename_variables, "Rename variables");
        resources.put(R.string.new_variables, "New variables:");
        resources.put(R.string.linear_bounded_automaton, "Linear Bounded Automaton:");
        resources.put(R.string.word, "Word:");
        resources.put(R.string.configurations, "Configurations:");
        resources.put(R.string.words, "Words:");
        resources.put(R.string.save, "Save");
        resources.put(R.string.machine, "Machine:");
        resources.put(R.string.delete_automaton, "Delete automaton");
        resources.put(R.string.transition, "Transition:");
        resources.put(R.string.transition_pda, "Transition - Pushdown Automaton");
        resources.put(R.string.pop, "Pop:");
        resources.put(R.string.symbol, "Symbol:");
        resources.put(R.string.push, "Push:");
        resources.put(R.string.transition_tm, "Transition - Turing Machine");
        resources.put(R.string.symbol_read, "Symbol (read):");
        resources.put(R.string.symbol_write, "Symbol (write):");
        resources.put(R.string.direction, "Direction:");
        resources.put(R.string.direction_right, "R");
        resources.put(R.string.direction_left, "L");
        resources.put(R.string.direction_static, "S");
        resources.put(R.string.transition_pda2, "Transitions - Pushdown Automaton");
        resources.put(R.string.num_tapes, "Number of tapes:");
        resources.put(R.string.num_tracks, "Number of tracks:");
        resources.put(R.string.regular_expression, "Regular expression: OBS: use the character \'/\' for the union operator.");
        resources.put(R.string.state, "State:");
        resources.put(R.string.initial_state, "Start");
        resources.put(R.string.final_state, "Final");
        resources.put(R.string.move_state, "Move");
        resources.put(R.string.algol_afnd_lambda_to_afd, "i. Are start states: closure-λ(q0)\n\t·If an start state reaches a final state, such start state will be final\nii. For the other states qi:\n\t·considers every state in closure-λ(qi)\n\t·consumes, stops in a state qj and then adds the closure-λ(qj)");
        resources.put(R.string.algol_afnd_to_afd, "i. It\'s start: the union of all start states: {q0}\nii. Each new Q obtains the union of the transitions of its member states\niii. Are final: states containing at least one final state");
        resources.put(R.string.conf_afnd_lambda_to_afd, "Step from transformation of AFND-λ to AFND successfully performed!\nDo you want to go to the transformation from AFND to AFD?");
        resources.put(R.string.exception_symbol_out_alphabet_1, "Word contains symbols that are not in the alphabet");
        resources.put(R.string.exception_symbol_out_alphabet_2, "of the automaton. Symbols:");
        resources.put(R.string.exception_symbol_out_alphabet, "Word contains symbols that are not in the alphabet of the automaton. Symbols:");
        resources.put(R.string.exception_previous_configuration, "First configuration. Can not go to previous.");
        resources.put(R.string.exception_clone, "Not possible clone this instance!");
        resources.put(R.string.exception_inconsistent_interact_quad, "Instance of InteractQuadrilateralArea is inconsistent!");
        resources.put(R.string.exception_edge_draw_type_not_found, "Edge draw type don\'t exist!");
        resources.put(R.string.exception_edge_draw_inconsistent, "Instance of EdgeDrawView is inconsistent!");
        resources.put(R.string.exception_not_find_initial_state, "Error! It has no start state!");
        resources.put(R.string.exception_not_find_final_state, "Error! It has no final state!");
        resources.put(R.string.exception_states_same_name, "Error. States with the same name (");
        resources.put(R.string.error, "Error!");
        resources.put(R.string.exception_edge_draw_not_definied, "EdgeDraw not definied!");
        resources.put(R.string.exception_transition_exists, "Transition already exists!");
        resources.put(R.string.exception_move_state, "Could not move this state!");
        resources.put(R.string.exception_lock_state, "Error! You can not create the lock state where another state already exists!Enter another position to create the lock state.");
        resources.put(R.string.exception_size_reference, "The reference size should be positive");
        resources.put(R.string.exception_vertex_draw_inconsistent, "Instance of VertexDrawView is inconsistent!");
        resources.put(R.string.exception_vertex_draw_type, "Vertex draw type don\'t exist!");
        resources.put(R.string.confirm, "Confirm");
        resources.put(R.string.fast_edition_mode, "Quick edit mode!");
        resources.put(R.string.alphabet_empty, "There are no characters in the alphabet!");
        resources.put(R.string.warning_max_chars_state, "Warning! Maximum size for state name are");
        resources.put(R.string.warning_max_chars_state2, "characters!");
        resources.put(R.string.exception_state_same_name, "Error! Machine already has state with this name!");
        resources.put(R.string.exception_lock_state2, "Error! Indicate where you should create the lock state, before moving a state.");
        resources.put(R.string.move_state1, "Indicate where");
        resources.put(R.string.move_state2, "should be moved.");
        resources.put(R.string.empty_char_tape, "B");
        resources.put(R.string.exception_transition_def, "Incorrect transition setting!");
        resources.put(R.string.initial_label_tm, "B/B S");
        resources.put(R.string.exception_loop_process, "Processing will not be completed due to possible loops");
        resources.put(R.string.transitions, "Transitions");
        resources.put(R.string.exceptions_transition_builder_args, "Transitions args array length different of types!");
        resources.put(R.string.exception_invalid_transition, "Invalid transition!");
        resources.put(R.string.exception_instance_not_found_for, "Instance not found for \'");
        resources.put(R.string.exception_instance_not_found, "Instance not found!");
        resources.put(R.string.machine_to_string_parameters, "States, Alphabet, Final states, Start state");
        resources.put(R.string.no_convert_this_step, "There are no transformations to be made at this stage!<br/>");
        resources.put(R.string.remove_recursion_acd, "Remove direct left recursion:<br/>");
        resources.put(R.string.replace_rues_acd, "Replace rules (A<sub>i</sub> → A<sub>j</sub>γ):<br/>");
        resources.put(R.string.remove_indirect_left_recursion_terra, "Remove indirect left recursion (replace rules A<sub>i</sub> → A<sub>j</sub>γ):<br/>");
        resources.put(R.string.new_grammar, "New grammar:<br/>");
        resources.put(R.string.initial_symbol_not_recursive, "The start symbol should be limited to start derivations, and can not be a recursive variable.Therefore, it should not be possible to have derivations of type");
        resources.put(R.string.recursion_found_initial, "Recursion found in rule");
        resources.put(R.string.recursion_initial_symbol_solution_descr_parameters, "The grammar # has the start symbol # recursive. Therefore, there is a CFG #such that L(G\') = L(G) and the new start symbol #  is not recursive.");
        resources.put(R.string.esentially_noncontracting_problems_parameters, "- The rule # is an empty production.");
        resources.put(R.string.grammar_to_string_parameters, "Variables: #Terminals: #Start symbol: # Rules:");
        resources.put(R.string.exception_not_attr_prod_to_var, "No productions were attributed to the variable \'");
        resources.put(R.string.exception_rule_not_in_grammar, "- In the reported grammar, the rule");
        resources.put(R.string.exception_rule_not_regular_2, "does not belong to the set of regular grammars.");
        resources.put(R.string.exception_rule_not_context_free_2, "does not belong to the set of context-free grammars.");
        resources.put(R.string.exception_rule_not_sensitive_free_2, "does not belong to the set of context sensitive grammars.");
        resources.put(R.string.exception_rule_not_unrestricteble_2, "does not belong to the set of unrestricted grammars.");
        resources.put(R.string.is_regular_grammar, "Therefore, the inserted grammar is a regular grammar (RG).");
        resources.put(R.string.is_context_free_grammar, "Therefore, the inserted grammar is a context-free grammar (CFG).");
        resources.put(R.string.is_sensible_context_grammar, "Therefore, the inserted grammar is a context sensitive grammar (CSG).");
        resources.put(R.string.is_unrestricted_grammar, "Therefore, the inserted grammar is an unrestricted grammar (UG).");
        resources.put(R.string.not_class_grammar_found, "Informed grammar is non-existent.");
        resources.put(R.string.grammar_have_empty_production, "The inserted grammar has lambda rules.");
        resources.put(R.string.grammar_have_recursion_initial_symbol, "The inserted grammar has recursion in the start symbol.");
        resources.put(R.string.exit, "Exit");
        resources.put(R.string.exit_lfapp, "Exit LFApp??");
        resources.put(R.string.yes, "Yes");
        resources.put(R.string.no, "No");
        resources.put(R.string.exception_derivation_tree_not_found, "Error! Parse tree not found!");
        resources.put(R.string.accept, "Accepts");
        resources.put(R.string.reject, "Rejects");
        resources.put(R.string.simplify_vars, "Simplify variables");
        resources.put(R.string.copy_grammar, "Copy grammar");
        resources.put(R.string.need_simplify_vars, "First it is necessary to simplify the variables.");
        resources.put(R.string.pda_to_cfg_stage3_parameters, "As#then#New rules");
        resources.put(R.string.array_adapter_automata_parameters, "Created on: #MM/dd/yyyy#Set of states: #Alphabet: #Start state: #Set of final states:");
        resources.put(R.string.exception_automaton_not_found, "Error! Automaton was not found!");
        resources.put(R.string.exception_not_previous_op, "You can not go back to the previous step!");
        resources.put(R.string.minim_fsa_title, "Deterministic finite automaton minimization algorithm");
        resources.put(R.string.mim_fsa_compl, "Minimized automaton!");
        resources.put(R.string.min_fsa_step_1_compl, "End of verification stage of final and non-final states!");
        resources.put(R.string.min_fsa_not_previous_step, "There is no previous step!");
        resources.put(R.string.min_fsa_table_header, "Index#D[i, j] =#S[i, j] =#Reason");
        resources.put(R.string.convert_compl, "Conversion made");
        resources.put(R.string.not_previous_acess, "Can not go back.");
        resources.put(R.string.convert_fsand_in_fsad_parameters, "NDFA#DFA#ND#D#closure");
        resources.put(R.string.exception_invalid_regex, "Invalid Regex!");
        resources.put(R.string.exception_fsa_not_completed, "Automaton is not a complete DFA!");
        resources.put(R.string.exception_fsa_not_deterministic, "Automaton is not a DFA!");
        resources.put(R.string.exception_fsa_already_deterministic, "Automaton is already a DFA!");
        resources.put(R.string.exception_fsa_already_completed, "Automaton is already complete!");
        resources.put(R.string.set_lock_state_position, "Enter a position to insert the lock state!");
        resources.put(R.string.exception_select_lock_state_position, "Error! Indicate where to move the selected state before generating the complete automaton.");
        resources.put(R.string.warning, "Warning");
        resources.put(R.string.exception_invalid_grammar, "Invalid grammar.");
        resources.put(R.string.exception_pda_not_found, "Error! Pushdown automaton not found!");
        resources.put(R.string.grammar_in_gnf, "Grammar in the Greibach Normal Form:");
        resources.put(R.string.new_transitions_2, "New transitions:");
        resources.put(R.string.not_find_ambiguity, "No ambiguity was found in the tests performed.");
        resources.put(R.string.find_ambiguity, "Ambiguity was found for the word(s) below.");
        resources.put(R.string.lfapp_cnf_title, "LFApp - CNF");
        resources.put(R.string.lfapp_gnf_title, "LFApp - GNF");
        resources.put(R.string.lfapp_left_recursion_title, "LFApp - Left Recursion");
        resources.put(R.string.chain_rules_algol_comment, "The removal of chain rules consist in replaces the occurrences of a chain rule directly by the rules of chain variable.");
        resources.put(R.string.algol_chain_rule_grammar_step_1, "(1) The first step of the algorithm is to construct the set CHAIN of each variable.");
        resources.put(R.string.algol_chain_rule_grammar_step_2, "(2) Highlight the chain rules found.");
        resources.put(R.string.algol_chain_rule_grammar_step_2_1, "(2) In the inserted grammar, there are auto chain rules.This rule type should also be removed.");
        resources.put(R.string.algol_chain_rule_grammar_step_2_2, "(2) There are no chain rules in the inserted grammar.");
        resources.put(R.string.algol_chain_rule_grammar_step_3, "(3) Replace chains found.");
        resources.put(R.string.algol_chain_rule_grammar_step_3_1, "(3) In the inserted grammar, there are auto chain rules.This rule type should also be removed.");
        resources.put(R.string.algol_chain_rule_grammar_step_3_2, "(3) There are no chain rules in the inserted grammar.");
        resources.put(R.string.chain_rules_table_header, "Variable#Chain");
        resources.put(R.string.chain_rule_algol, "CHAIN(A) = {A}<br>PREV = ∅<br><b>repeat</b><br>&nbsp;&nbsp;NEW = CHAIN(A) − PREV<br>&nbsp;&nbsp;PREV = CHAIN(A)<br>&nbsp;&nbsp;<b>for each</b> B ∈ NEW <b>do</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for each</b> B → C <b>do</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CHAIN(A) = CHAIN(A) ∪ {C}<br><b>until</b> CHAIN(A) == PREV");
        resources.put(R.string.chomsky_normal_form_algol_comments, "A CFG G = (V, Σ, P, S) is in the Chomsky Normal Form if its rules have one of the following forms:\ni)   A → BC\nii)  A → a\niii) S → λ\nwhere B, C ∈ V − {S} and a ∈ Σ");
        resources.put(R.string.chomsky_normal_form_step_1, "(1) Identify rules that are not in Chomsky Normal Form.");
        resources.put(R.string.chomsky_normal_form_step_2, "(2) Convert these rules into one of the valid formats.");
        resources.put(R.string.chomsky_normal_form_already_cnf, "The inserted grammar is already in Chomsky Normal Form.");
        resources.put(R.string.cyk_and_so_on, "And so on.");
        resources.put(R.string.cyk_there_any_rule, "Are there any rules that produce");
        resources.put(R.string.cyk_step_3, "(3) The third step of the algorithm is add to the table the variables that produce strings of size three.");
        resources.put(R.string.cyk_step_2, "(2) The second step of the algorithm is add to the table the variables that produce strings of size two.");
        resources.put(R.string.directly, "directly");
        resources.put(R.string.cyk_step_1, "(1) The first step of the algorithm is add to the table the variables that produce the respective terminals directly.");
        resources.put(R.string.cyk_comments, "The grammar inserted is not in Chomsky Normal Form. Therefore, a transformation was necessary.");
        resources.put(R.string.no_derivation_for_the_word, "No derivations were found for the word.");
        resources.put(R.string.derivation, "Derivation:");
        resources.put(R.string.two_derivations_1, "Two derivations were found for the word, so this grammar is ambiguous.\nDerivation 1:\n");
        resources.put(R.string.two_derivations_2, "\nDerivation 2:\n");
        resources.put(R.string.nullable_algol, "NULL = {A | {A → λ} ∈ P}<br><b>repeat</b><br>&nbsp;&nbsp;&nbsp;&nbsp;PREV = NULL<br>&nbsp;&nbsp;&nbsp;&nbsp;<b>for each</b> A ∈ V <b>do</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> A → w and w ∈ PREV<sup>∗</sup> <b>do</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL = NULL ∪ {A}<br><b>until</b> NULL == PREV");
        resources.put(R.string.removal_empty_prod_comments, "<p align=justify>The algorithm for removing lambda rules consists of 3 steps:");
        resources.put(R.string.removal_empty_prod_step_1, "(1) Determine the set of nullable variables.</p>");
        resources.put(R.string.removal_empty_prod_step_2, "(2) Add rules in which occurrences of null variables are omitted.For example, assume rule A → BABa and B is a nullable variable.Therefore, the following rules are inserted: A → ABa, A → BAa and A → Aa.");
        resources.put(R.string.removal_empty_prod_step_2_1, "(2) There are no rules to be inserted.");
        resources.put(R.string.removal_empty_prod_step_3, "(3) Remove the lambda rules. NOTE: if start symbol produces λ, do not remove this rule.");
        resources.put(R.string.removal_empty_prod_step_3_1, "(3) There are no rules to remove.");
        resources.put(R.string.no_empty_prod, "The inserted grammar does not have lambda rules.");
        resources.put(R.string.greibach_normal_formal_comments, "A CFG G = (V, Σ, P, S) is in the Greibach Normal Form if its rules have one of the following forms:<br>- A → aA<sub><small>1</small></sub>A<sub><small>2</small></sub>A<sub><small>3</small></sub>…A<sub><small>n</small></sub>&nbsp&nbsp&nbsp&nbsp where a ∈ Σ e A<sub><small>1</small></sub>… A<sub><small>n</small></sub> ∈ V − {S}<br>- A → a&nbsp&nbsp&nbsp&nbsp where a ∈ Σ<br>- A → λ");
        resources.put(R.string.greibach_normal_formal_already, "The inserted grammar is already in the Greibach Normal Form.");
        resources.put(R.string.regular_grammar_abr, "RG");
        resources.put(R.string.context_free_grammar_abr, "CFG");
        resources.put(R.string.context_sensible_grammar_abr, "CSG");
        resources.put(R.string.unrestricted_grammar_abr, "UG");
        resources.put(R.string.result_red, "<b><font color=red>Result:</b><br>");
        resources.put(R.string.reach_cnf_comments, "Remove unreachable variables is the process of remove all variables that not be derivable from the start symbol.");
        resources.put(R.string.reach_cnf_step_1, "(1) Determine which variables are reachable from the start symbol");
        resources.put(R.string.reach_cnf_step_2, "(2) Remove variables that are not in");
        resources.put(R.string.reach_cnf_step_2_1, "(2) All symbols are reachable.");
        resources.put(R.string.reach_cnf_step_comments_2, "There are no reachable symbols in the inserted grammar.");
        resources.put(R.string.reach_cnf_algol, "REACH = {S}<br>PREV = ∅<br><b>repeat</b><br>&nbsp;&nbsp;&nbsp;NEW = REACH − PREV<br>&nbsp;&nbsp;&nbsp;PREV = REACH<br>&nbsp;&nbsp;&nbsp;<b>for each</b> A ∈ NEW <b>do</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>for each</b> A → w <b>do</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add the variables of w in REACH<br><b>until</b> REACH == PREV");
        resources.put(R.string.term_cnf_comments, "Removes rules that do not produce terminals:");
        resources.put(R.string.term_cnf_step_1, "(1) Determine which variables produce terminals directly and indirectly.");
        resources.put(R.string.term_cnf_step_2, "(2) Remove variables that are not in");
        resources.put(R.string.term_cnf_result, "All grammar variables generate terminal strings.");
        resources.put(R.string.term_cnf_algol, "TERM = {A | there is a rule A → w ∈ P, com w ∈ Σ<sup>∗</sup> }<br><b>repeat</b><br>&nbsp;&nbsp;PREV = TERM<br>&nbsp;&nbsp;<b>for each</b> A ∈ V <b>do</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> A → w ∈ P e w ∈ (PREV ∪ Σ)<sup>∗</sup> <b>then</b><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TERM = TERM ∪ {A}<br><b>until</b> PREV == TERM");
        resources.put(R.string.rem_initial_rec_step_1_1, "The inserted grammar does not have rules of the type");
        resources.put(R.string.rem_initial_rec_step_1_2, "Therefore, no changes were made.");
        resources.put(R.string.rem_left_direct_recursion_comments, "Direct left recursion can produce loops in top-down parsers.");
        resources.put(R.string.rem_left_direct_recursion_step_1, "(1) The first step is to identify recursion.");
        resources.put(R.string.rem_left_direct_recursion_algol_not_used, "for i = 1 to n do     if A<sub><small>i</sub></small> has direct left recursion then         eliminate recursion in A<sub><small>i</sub></small>     for j = i+1 to n do         for each production in A<sub><small>j</sub></small> do             if A<sub><small>j</sub></small> → <sub><small>i</sub></small>Y then                 replace A<sub><small>j</sub></small> → <sub><small>i</sub></small>Y with A<sub><small>j</sub></small> → T<sub><small>1</sub></small>Y | T<sub><small>2</sub></small>Y | … | T<sub><small>k</sub></small>Y, where A<sub><small>i</sub></small> → T<sub><small>1</sub> | T<sub><small>2</sub> | … | T<sub><small>k</sub> are all current productions of A<sub><small>i</sub></small>");
        resources.put(R.string.rem_left_direct_recursion_step_2, "(2) The second step is to solve the recursion.");
        resources.put(R.string.rem_left_direct_recursion_comments_2, "The inserted grammar does not have direct left recursion.");
        resources.put(R.string.rem_left_direct_recursion_algol, "Suppose the generic rule directly left recursive:<br>A → Aμ<sub><small>1</small></sub> | Aμ<sub><small>2</small></sub> | … | Aμ<sub><small>m</small></sub> | ν<sub><small>1</small></sub> | ν<sub><small>2</small></sub> | … | ν<sub><small>n</small></sub><br><br>Equivalent rule without left recursion:<br>A → ν<sub><small>1</small></sub> | ν<sub><small>2</small></sub> | … | ν<sub><small>n</small></sub> | ν<sub><small>1</small></sub>Z | ν<sub><small>2</small></sub>Z | … | ν<sub><small>n</small></sub>Z<br>Z → μ<sub><small>1</small></sub>Z | μ<sub><small>2</small></sub>Z | … | μ<sub><small>m</small></sub>Z | μ<sub><small>1</small></sub> | μ<sub><small>2</small></sub> | … | μ<sub><small>m</small></sub><br><br>");
        resources.put(R.string.remove_left_recursion_comments, "Removal left recursion consists of sorting the grammar variables and organizing the rules so that the left-hand variable always has a lower value than the right-hand variable.");
        resources.put(R.string.remove_left_recursion_step_1, "(1) Sort the grammar variables.");
        resources.put(R.string.remove_left_recursion_table_header, "Variable#Value");
        resources.put(R.string.remove_left_recursion_dont_have, "The inserted grammar has no left recursion.");
        resources.put(R.string.lfapp_about, "LFApp - About");
        resources.put(R.string.lfapp_menu, "LFApp - Menu");
        resources.put(R.string.lfapp_cnf, "LFApp - CNF");
        resources.put(R.string.lfapp_left_recursion, "LFApp - Left Recursion");
        resources.put(R.string.lfapp_gnf, "LFApp - GNF");
        resources.put(R.string.lfapp_gnf_8_8, "LFApp - GNF - 7/7");
        resources.put(R.string.lfapp_history, "LFApp - History");
        resources.put(R.string.compl_automaton, "Complete Automaton");
        resources.put(R.string.processar_palavra, "word_process");
        resources.put(R.string.convert_fsand_fsad, "Convert NDFA into DFA");
        resources.put(R.string.convert_fsand_fsad_step_by_step, "Convert NDFA into DFA step by step");
        resources.put(R.string.min_fsa, "Minimize DFA");
        resources.put(R.string.min_fsa_step_by_step, "Minimize DFA step by step");
        resources.put(R.string.min_fsand_regular_expression, "Create NDFA with Regular Expression");
        resources.put(R.string.pda_to_grammar, "Convert automaton into grammar");
        resources.put(R.string.pda_to_grammar_step_by_step, "Convert automaton into grammar step by step");
        resources.put(R.string.word_process_pda, "Word processing");
        resources.put(R.string.word_process_enumerator_tm, "Word Process as Turing Machine Enumerator");
        resources.put(R.string.word_process_multi_tape_tm, "Word Process as Turing Machine Multi-tapes");
        resources.put(R.string.word_process_multi_track_tm, "Word Process as Turing Machine Multi-tracks");
        resources.put(R.string.word_process_turing_machine, "Word Process as Turing Machine");
        resources.put(R.string.word_process_linear_bounded_automaton, "Word Process as Linear bounded automaton");
    }

    public static String getString(int id) {
        return resources.get(id);
    }
}
